# Cool-Compiler-
  Create compiler for cool programming language

# Prerequisites:
  You need to install antlr4 with your IDE, if you had no information for how to do that follow this [link](https://github.com/antlr/antlr4/blob/master/doc/java-target.md).


# Steps:

  * Click right on Cool.g4 file then select "generate antlr recognizer".
  
  ![setup](https://i.ibb.co/V2RQXSX/Capture.png)
  
  This will generate a set of files in "gen" folder.

  * Move the main file to "gen" folder.
  
  * Change the project src folder from src to gen.
  from menu choose : file >> program structure >> Modules >> sources
  
  ![setup](https://i.ibb.co/DR7Xsrn/Capture.png)

  * Now we should compile our project. 
   right click on any file on gen folder then select "open in terminal".
   write in the terminal the following command:
   
   >javac Main.java CoolBaseListener.java CoolBaseVisitor.java CoolLexer.java CoolListener.java CoolParser.java CoolVisitor.java


# Compiler structure: 

  compiler is divided into few sequential steps: lexical analysis, parsing, semantic rules, three address code generation.

## Lexer:

   Define the language terminals throughout some [regex](https://www.rexegg.com/regex-quickstart.html).

   Here there are 2 files in folder testCases to test the lexer one with good terminals and one for bad.
  
### Testing:

  - Run main and give it this input :  > testCases/goodLexer.cl 
  
  You'll get this output file ([goodLexer](https://github.com/Wafaaismail/Cool-Compiler-/blob/master/output/good.cl-lex)

  - Run main and give it this input :  > testCases/badLexer.cl
  
  It won't produce a file so this is the output.
  
  ![result1](https://i.ibb.co/V9r4TTk/Capture.png)
  
## Parser:
  
  Define the grammer of COOL in [Cool.g4](https://github.com/Wafaaismail/Cool-Compiler-/blob/master/src/Cool.g4) file.
  
  To test the grammer, there's a program which checks whether the number is a palindrome or not written in COOL. 
 
### Testing:

   - Run main and give it this input :  > testCases/goodParser.cl 
   
   It will produce 2 files ,its tokens file generated by lexer (([goodParser](https://github.com/Wafaaismail/Cool-Compiler-/blob/master/output/goodParser.cl-lex)) and the parse tree of this code which shown below here.
   
   ![tree](https://github.com/Wafaaismail/Cool-Compiler-/blob/master/output/parseTree.png)
   


  - Run main and give it this input :  > testCases/badParser.cl
  
  It will show the error in the file and where it's.
  
 example:
  
  ![result](https://i.imgur.com/WcXw5UQ.png)
  
## Semantic rules:

## 3 address code generation:

ANTLR4 Provides 2 Methods to generate 3 address code

1- Listener Method

2- Visitor Method

### Diferences between them:

1-Listener methods are called automatically by the ANTLR provided walker object, whereas visitor methods must walk their children with explicit visit calls. Forgetting to invoke visit() on a node’s children means those subtrees don’t get visited.

2-Listener methods can’t return a value, whereas visitor methods can return any custom type. 

3-With listener, you will have to use mutable variables to store values, whereas with visitor there is no such need.

4-Listener uses an explicit stack allocated on the heap, whereas visitor uses call stack to manage tree traversals.

5-to directly use the parser output for interpretation, the visitor is a good choice. You have full control of the traversal, so in conditionals only one branch is visited, loops can be visited n times and so on.

so we use Visitor method

example:
#### Original code:
![original code](https://i.imgur.com/K3tIIE9.png)

#### Three Adress Code:
![original code](https://i.imgur.com/tLbF9Z0.png)
